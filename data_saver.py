#!/usr/bin/python !/usr/bin/env python
# -*- coding: utf-8 -*


# Functions to extract knowledge from medical text. Everything related to 
# reading, parsing and extraction needed for the knowledge base. Also,
# some wrappers for SemRep, MetaMap and Reverb.

import json
import os
import py2neo
import csv
import subprocess
import urllib2
import requests
import unicodecsv as csv2
import pandas as pd
from config import settings
from utilities import time_log


def save_json(json_):
    """
    Helper function to save enriched medical json to file.
    Input:
        - json_: dic,
        json-style dictionary generated from the extractors in the
        previous phase
    """

    # Output file location from settings
    outfile = settings['out']['json']['out_path']
    with open(outfile, 'w+') as f:
        json.dump(json_, f, indent=3)



def save_csv(json_):
    """
    Helper function to save enriched medical json to file.
    Input:
        - json_: dic,
        json-style dictionary generated from the extractors in the
        previous phase
    """

    # Output file location from settings
    outfile = settings['out']['json']['out_path']
    with open(outfile, 'w+') as f:
        json.dump(json_, f, indent=3)



def save_neo4j(json_):
    """
    Helper function to save enriched medical json to file.
    Input:
        - json_: dic,
        json-style dictionary generated from the extractors in the
        previous phase
    """

    # Output file location from settings
    outfile = settings['out']['json']['out_path']
    with open(outfile, 'w+') as f:
        json.dump(json_, f, indent=3)

def aggregate_mentions(entity_pmc_edges):
    """
    Function to aggregate recurring entity:MENTIONED_IN:pmc relations.
    Input:
        - entity_pmc_edges: list,
        list of dicts as generated by create_neo4j_graph
    Outpu:
        - entity_pmc_edges: list,
        list of dicts with aggregated values in identical ages
    """
    uniques = {}
    c = 0
    for edge in entity_pmc_edges:
        cur_key = str(edge[':START_ID'])+'_'+str(edge[':END_ID'])
        flag = False
        if cur_key in uniques:
            uniques[cur_key]['score:float[]'] = uniques[cur_key]['score:float[]']+';'+edge['score:float[]']
            uniques[cur_key]['sent_id:string[]'] = uniques[cur_key]['sent_id:string[]']+';'+edge['sent_id:string[]']
            flag = True
        else:
            uniques[cur_key] = edge
        if flag:
            c += 1
    un_list = []
    time_log('Aggregated %d mentions from %d in total' % (c, len(entity_pmc_edges)))
    for k, v in uniques.iteritems():
        un_list.append(v)
    return un_list


def aggregate_relations(relations_edges):
    """
    Function to aggregate recurring entity:SEMREP_RELATION:entity relations.
    Input:
        - relations_edges: list,
        list of dicts as generated by create_neo4j_graph
    Outpu:
        - relations_edges: list,
        list of dicts with aggregated values in identical ages
    """
    uniques = {}
    c = 0
    for edge in relations_edges:
        cur_key = str(edge[':START_ID'])+'_'+str(edge[':TYPE'])+'_'+str(edge[':END_ID'])
        flag = False
        if cur_key in uniques:
            if not(edge['sent_id:string[]'] in uniques[cur_key]['sent_id:string[]']):
                for field in edge.keys():
                    if not(field in [':START_ID', ':TYPE', ':END_ID']):
                        uniques[cur_key][field] = uniques[cur_key][field]+';'+edge[field]
                flag = True
        else:
            uniques[cur_key] = edge
        if flag:
            c += 1
    un_list = []
    time_log('Aggregated %d relations from %d in total' % (c, len(relations_edges)))
    for k, v in uniques.iteritems():
        un_list.append(v)
    return un_list


def create_neo4j_graph(json_):
    """
    Function that takes the enriched json_ file and generated the nodes
    and relationships entities needed for creating/updating the neo4j database.
    Currently supporting: 
        - Nodes: ['Articles(PMC)', 'Entities(MetaMapConcepts)', 'MESH(Headings)'] 
        - Edges: ['Relations between Entities', 'Entity:MENTIONED_IN:Article'
                  'Entiy:HAS_MESH:MESH']
    Input:
        - json_: dic,
        json-style dictionary generated from the extractors in the
        previous phase
    Output:
        - entities_nodes: list,
        list of dictionaries each containing an entity node
        - articles_nodes: list,
        list of dictionaries each containing an article node
        - mesh_nodes:list,
        list of dictionaries each containing an MESH node
        - entity_pmc_edges: list,
        list of dictionaries each containing an entity_cui-
        MENTIONED_IN-pmc_id relation
        - relations_edges: list,
        list of dictionaries each containing an entity_cui-
        SEMREP_RELATION-entity_cui relation
        - pmc_mesh_edges:list,
        list of dictionaries each containing a pmc_id-HAS_MESH-
        -mesh_id relation
    """
    entities_nodes = []
    unique_sent = {}
    articles_nodes = []
    entity_pmc_edges = []
    relations_edges = []
    unique_cuis = []
    mesh_nodes = []
    unique_mesh = []
    pmc_mesh_edges = []
    cui_to_mesh_path = settings['load']['mesh']['path']
    with open(cui_to_mesh_path, 'r') as f:
        mapping = json.load(f)['cuis']
    for doc in json_['documents']:
        pmid = doc['pmid']
        tmp_sents = []
        doc_mesh = []
        for sent in doc['sents']:
            cur_sent_id = str(pmid)+'_'+sent['sent_id']
            tmp_sents.append(cur_sent_id)
            unique_sent[cur_sent_id] = sent['sent_text']
            for ent in sent['entities']:
                if ent['cuid']:
                    if (ent['cuid'] in mapping):
                        doc_mesh.append(ent['cuid'])
                        cur_map = mapping[ent['cuid']]
                        for i, id_ in enumerate(cur_map['ids']):
                            if not(id_ in unique_mesh):
                                unique_mesh.append(id_)
                                mesh_nodes.append({'mesh_id:ID': id_, 'label': cur_map['labels'][i]})
                    if ent['cuid'] in unique_cuis:
                        continue
                    else:
                        unique_cuis.append(ent['cuid'])
                        if (type(ent['sem_types']) == list and len(ent['sem_types']) > 1):
                            sem_types = ';'.join(ent['sem_types'])
                        elif (',' in ent['sem_types']):
                            sem_types = ';'.join(ent['sem_types'].split(','))
                        else:
                            sem_types = ent['sem_types']
                        #if not(ent['cuid']):
                        entities_nodes.append({'cui:ID': ent['cuid'], 
                                         'label': ent['label'], 
                                         'sem_types:string[]': sem_types})
                    entity_pmc_edges.append({':START_ID': ['cuid'],
                                             'score:float[]': ent['score'],
                                             'sent_id:string[]': cur_sent_id,
                                             ':END_ID': pmid})
            for rel in sent['relations']:
                if rel['subject__cui'] and rel['object__cui']:
                    relations_edges.append({':START_ID': rel['subject__cui'],
                                     'subject_score:float[]': rel['subject__score'],
                                     'subject_sem_type:string[]': rel['subject__sem_type'],
                                     ':TYPE': rel['predicate'].replace('(','__').replace(')','__'),
                                     'pred_type:string[]': rel['predicate__type'],
                                     'object_score:float[]': rel['object__score'],
                                     'object_sem_type:string[]': rel['object__sem_type'],
                                     'sent_id:string[]': cur_sent_id,
                                     'negation:string[]': rel['negation'],
                                     ':END_ID': rel['object__cui']})            
        articles_nodes.append({'pmcid:ID': doc['pmid'], 
                               'title': doc['title'], 
                               'journal': doc['journal'], 
                                'sent_id:string[]': ';'.join(tmp_sents)})
        for doc_cui in doc_mesh:
            try:
                cur_map = mapping[doc_cui]
                for id_ in cur_map['ids']:
                    pmc_mesh_edges.append({':START_ID': doc['pmid'], 
                                   ':TYPE': 'HAS_MESH', 
                                    ':END_ID':id_})
            except KeyError:
                continue
    entity_pmc_edges = aggregate_mentions(entity_pmc_edges)
    relations_edges = aggregate_relations(relations_edges)
    return entities_nodes, articles_nodes, mesh_nodes, entity_pmc_edges, relations_edges, pmc_mesh_edges


def create_neo4_csv(entities_nodes, articles_nodes, mesh_nodes, entity_pmc_edges,relations_edges, pmc_mesh_edges):
    """
    Create csv's for use by the neo4j import tool. Relies on create_neo4j_graph
    output and transforms it to suitable format for automatic importing.
    Input: Check create_neo4j_graph output, exactly the same
    Output:
        - None just saves the documents in the allocated path as defined
        in settings.yaml 
    """
    outpath = settings['out']['csv']['out_path']
    dic_ = {
        'entities.csv': entities_nodes,
        'articles.csv': articles_nodes,
        'mesh.csv': mesh_nodes,
        'entities_pmc.csv':entity_pmc_edges, 
        'relations.csv':relations_edges,
        'pmc_mesh.csv':pmc_mesh_edges
    }

    dic_fiels = {
        'entities.csv': ['cui:ID', 'label', 'sem_types:string[]'],
        'articles.csv': ['pmcid:ID', 'title', 'journal','sent_id:string[]'],
        'mesh.csv':['mesh_id:ID', 'label'],
        'entities_pmc.csv':[':START_ID','score:float[]','sent_id:string[]', ':END_ID'], 
        'relations.csv':[':START_ID','subject_score:float[]','subject_sem_type:string[]',':TYPE','pred_type:string[]', 'object_score:float[]','object_sem_type:string[]','sent_id:string[]','negation:string[]',':END_ID'],
        'pmc_mesh.csv': [':START_ID',':TYPE', ':END_ID']
    }

    for k, toCSV in dic_.iteritems():
        keys = toCSV[0].keys()
        out = os.path.join(outpath, k)
        with open(out, 'wb') as output_file:
            time_log("Created file %s" % k)
            dict_writer = csv2.DictWriter(output_file, fieldnames=dic_fiels[k], encoding='utf-8')
            dict_writer.writeheader()
            dict_writer.writerows(toCSV)
    time_log('Created all documents needed')

def update_neo4j(entities_nodes, articles_nodes, mesh_nodes, entity_pmc_edges,relations_edges, pmc_mesh_edges):
    
    """
    Function to create/update a neo4j database according to the nodeg and edges
    generated by the create_neo4j_graph.
    """